良いsqlとは
・メンテナンスしやすい
→自分が書いたsqlを見るのは他人
・パフォーマンスが良い
→実行頻度、同時アクセスが増加しても導入当初とと同等のレスポンスを維持できる

悪いｓｑｌとは
・必要以上のデータを表示する
→パフォーマンス烈火の原因
→セキュリティ上の問題
・索引を使用せず、全権検索をする
→パフォーマンス烈火の原因 i/oの増加、メモリの非効率的利用
静的sql
コンパイル時にsql完成
動的sql
sql実行時
＝変更できる


・sqlインジェクション攻撃 注入する
データベースを改ざんしたり不正に情報を入手する攻撃

セキュリティの観点から見たいいsql
・適切なデータ型の使用
→数値型の列は数値であることのチェック
・入力値を適切にエスケープ
・バインド機構の使用
→データ型とsqlの式が確定したものになる

SQLの共有
・ハード解析
→新規に実行計画を作成 1回目のsqlの実行はハード解析となる
→共有プールに保存
・ソフト解析
→既存の実行計画を再利用

sql解析のしくみ
1.文法的チェック
2.構造解析　検索→あり→再利用(ソフト解析)
3.最適化　
4.コンパイル　実行できるコード
5.Pコード parse　解析済みのコード

sqlの共有
再利用の基準
・同じsqlを記述する
→大文字/小文字仕様のルール
→インデント、改行の入れ方の統一
select ⇔　SELECT 異なるsql

・バインド変数を使用する
emp_id=100 ⇔ emp_id=200 異なるsqlだが
バインド変数を用いる→　emp_id=:eid 実行時に値が渡される

不要なデータを読み込まない
select * from orders where id=20
これだと 全件検索されてフィルタをかける→不要なデータを読み込んでいる
対称を5%以下にできるならインデックス索引がいい

早くなる要因の索引
・データ読み込みI/0の軽減　データバッファの効率的な利用
対象となるブロック/ページのみをロードする

索引を使用できないsql
・where句の列に関数を使う
→列とは異なるデータ型を使う（暗黙の型変換）
・索引を使用しない演算子を使う
→not演算子
→単一列に対するis null
→中間・後方一致の曖昧検索
等価条件　範囲条件はできる　

